# labHeredity

# main:

 int main() { 
    A* a1 = new B;    
    a1->foo();    
    a1->bar();    
    a1->baz();    
          
    A* a2 = new C;     
    a2->foo();    
    a2->bar();    
    a2->baz();    
}

# рез-т:

B::foo.  
B::bar.  
A::baz. 
C::foo. 
C::bar. 
A::baz. 

# объяснение 
 ! строка 7 : вызваем функцию foo класса B , потому что она переопределена в таблице виртаульных функций,  результат будет B::foo    
 ! строка 8 : вызваем функцию bar класса B , потому что она переопределена в таблице виртаульных функций, результат будет B::bar.    
 ! строка 9 : вызваем функцию baz класса B,но  она не виртуальна в классе А ,поэтому и не была переорпеделена в таблице виртаульных функций "A::baz" ,поэтому и в результате A::baz. 

 ! строка 12 : вызваем функцию foo класса C,потому что она переопределена сначала в В, а потом и в С ,поэтому  C::foo.  
 ! строка 13 : вызваем функцию bar класса  и в резултате C::bar,потому что  хоть в В функция  bar и не виртаул ,она в таблице виртальных функций все равно будет переопределена конструктором класса С ,тк в классе А функция виртуал.  
 ! строка 14 : вызваем функцию baz класса C,но она не виртаульна в классе А, поэтому и не была переопределена в таблице виртальных функций,результат поэтому A::baz.  
 
